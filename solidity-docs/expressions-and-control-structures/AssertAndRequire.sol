// SPDX-License-Identifier: GPL-3.0 

pragma solidity ^0.8.4;

contract C {
    
    /*
    
                            Panic via assert and Error via require
    
        The assert function creates an error of type Panic(uint256).
        assert should only be user to test for internal errors, and to check invariants.
        
        Properly functioning code should never create a Panic, not even on invalid external input.
        If this happens, then there is a bug in your contract which you should fix.
        
        A Panic exception is generated in the following situations. 
        The error code supplied with the error data indicates the kind of panic.
            
            1) If you call assert with an argument that evaluates to false.
            
            2) If an arithmetic operation results in underflow or overflow outside of an 
            unchecked { ... } block.
            
            3) If you divide or modulo by zero (e.g. 3/0 or 15 % 0).
            
            4) If you convert a value that is too big or negative into an enum type.
            
            5) If you access a storage byte array that is incorrectly encoded.
            
            6) If you call .pop() on an empty array.
            
            7) If you access and array, bytesN or an array slice at an out-of-bonds
            or negative index.
            
            8) If you allocate too much memory or create an array that is too large.
            
            9) If you call a zero-initialized variable of internal function type.
    
        
        
        
        The require function either creates an error without any data or an 
        error of type Error(string). It should be used to ensure valid conditions 
        that cannot be detected until execution time. This includes conditions 
        on inputs or return values from calls to external contracts.

        Note: It is currently not possible to use custom errors in combination with require.
        Please use if(!condition) revert CustomError(); instead.
        
        An Error(string) exception (or an exception without data) is generated by the compiler in the following situations:
        
            1) Calling require(x) where x evaluates to false.
            
            2) If you use revert() or revert("description")
            
            3) If you perform an external function call targeting a
            contract that contains no code.
            
            4) If your contract receives Ether via a public function without payable
            modifier (including the constructor and the fallback function).
            
            5) If your contract receiver Ether via a public getter function.
            
        For the following cases, the error data from the external call (if provided) is forwarded.
        This mean that it can either cause an Error or a Panic (or whatever else was given):
            
            1) If a .transfer() fails.
            
            2) If you call a function via a message call but it does not finish properly (i.e., it 
            runs out of gas, has no matching function, or throws an exception itself), except when 
            a low level operation call, send, delegatecall, callcode or staticcall is used.
            
            3) If you create a contract using the new keyword but the contract creation does not finish properly.
            
        You can optionally provide a message string for require, but not for assert.
        
        NOTE: If you do not provide a string argument to require, it will revert with empty error data, 
        not even including the error selector.
        
        
        
        The following example shows how you can use require to check conditions 
        on inputs and assert for internal error checking.
        
    */
    
    function sendHalf(address payable addr) public payable returns (uint balance) {
        require(msg.value % 2 == 0, "Even value required.");
        uint balanceBeforeTransfer = address(this).balance;
        addr.transfer(msg.value / 2);
        
        /*
        
            Since transfer throws an exception on failure and cannot 
            call back here, there should be no way for us to 
            still have half of the money.
            
        */
        assert(address(this).balance == balanceBeforeTransfer - msg.value / 2);
        return address(this).balance;
        
        /*
        
            Internally, Solidity performs a revert operation 
            (instruction 0xfd). This causes the EVM to revert all 
            changes made to the state. The reason for reverting is 
            that there is no safe way to continue execution, because 
            an expected effect did not occur. Because we want to keep 
            the atomicity of transactions, the safest action is to 
            revert all changes and make the whole transaction 
            (or at least call) without effect.
        
        */
    }
    
    
}
